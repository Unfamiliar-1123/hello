<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 





     -->
     <ul>
         <li>111</li>
         <li>222</li>
         <li>333</li>
     </ul>

     <script>

         function a(){
             console.log(this)
         }
         a();
         //函数中this指向window



         setTimeout(function(){
            console.log(this)
         },10)
         //定时器中this指向window


         var aLi = document.getElementsByTagName('li');
         for(var i = 0;i < aLi.length;i++){
             aLi[i].onclick = function(){
                 setTimeout((function(){
                     console.log(this);
                 }).bind(this),1000)
                
             }
         }
         //绑定事件,this指向点击的事件
         //计时器此时点击事件指向window，但用bind后，改变this指向，指向点击事件本身(方法不调用的时候只能用bind,不能用call)


         var obj2 = {
             name:'llo'
         }

         var obj = {
             name:'ff',
             age:24,
             say:function(msg,msg1,msg2){
                 console.log(this,msg,msg1,msg2)
             }
         }
         obj.say("I'm a boy","lala","haha");
         //**.方法   this指向**

         obj.say.call(obj2,"I'm a boy","lala","haha");
         obj.say.apply(obj2,["I'm a boy","lala","haha"]);
         obj.say.bind(obj2,"I'm a boy","lala","haha")();


         /*
         改变this指向
            （1）call()
            （2）apply()
            （3）bind()
         
         这三种方式的区别

         1.call，apply会调用，bind不会
         2.传参方式不同
            obj.say.call(obj2,"I'm a boy","lala","haha");
            obj.say.apply(obj2,["I'm a boy","lala","haha"]);
            obj.say.bind(obj2,"I'm a boy","lala","haha")();

         
         */

     </script>
</body>
</html>